import RPi.GPIO as GPIO
from time import sleep

###     Fonctions     ###

###     Setup     ###
GPIO.setmode(GPIO.BOARD)
PWMG = 7
MotorG_A = 12
MotorG_E = 22

PWMD = 18
MotorD_A = 16
MotorD_E = 15

SensorRoueG = 13
SensorRoueD = 26

compteurG = 0		#Counts number of rising edges generated by wheel encoder over distance
compteurD = 0
CurRotG = 0			#Variable used to count rotations
CurRotD = 0
RotationsG = 0		#Holds number of rotations of wheels
RotationsD = 0

GPIO.setup(SensorRoueG,GPIO.IN, pull_up_down=GPIO.PUD_UP)
GPIO.setup(SensorRoueD,GPIO.IN, pull_up_down=GPIO.PUD_UP)

GPIO.setup(PWMG,GPIO.OUT)
G = GPIO.PWM(PWMG,100)

GPIO.setup(PWMD,GPIO.OUT)
D = GPIO.PWM(PWMD,100)

#GPIO.setup(Motor1A,GPIO.OUT)
GPIO.setup(MotorG_A,GPIO.OUT)
GPIO.setup(MotorG_E,GPIO.OUT)

#GPIO.setup(Motor2A,GPIO.OUT)
GPIO.setup(MotorD_A,GPIO.OUT)
GPIO.setup(MotorD_E,GPIO.OUT)


	
def drive():
	print "Forward"
	#GPIO.output(Motor1A,GPIO.HIGH)

	G.start(70)   #PWM
	GPIO.output(MotorG_A,GPIO.LOW)
	GPIO.output(MotorG_E,GPIO.HIGH)

	#GPIO.output(Motor2A,GPIO.HIGH)
	
	D.start(55) #PWM
	GPIO.output(MotorD_A,GPIO.LOW)
	#GPIO.output(MotorD_E,GPIO.HIGH)
	
def stop():
	print "Stopping motor"
	GPIO.output(MotorG_E,GPIO.LOW)
	GPIO.output(MotorD_E,GPIO.LOW)



###     Interruptions for Capteur Roue Codeuse    ###
def IncrementSensorG(channel):
	global compteurG
	global CurRotG
	compteurG = compteurG + 1
	CurRotG = CurRotG + 1
	if CurRot == 20:
		Rotations = Rotations + 1
		CurRotG = 0

def IncrementSensorD(channel):
	global compteurD
	global CurRotD
	compteurD = compteurD + 1
	CurRotD = CurRotD + 1
	if CurRot == 20:
		Rotations = Rotations + 1
		CurRotD = 0
	
GPIO.add_event_detect(SensorRoueD, GPIO.RISING, callback = IncrementSensorG, bouncetime = 20)
GPIO.add_event_detect(SensorRoueG, GPIO.RISING, callback = IncrementSensorD, bouncetime = 20)

drive()
sleep(3)
nombre_de_trous = (compteurD + compteurG) / 2					#Average number of holes
distance_mesuree_m = (2*math.pi*3.4*nombre_de_trous)/(100*20)	#Calculate average distance
print "compteurD = %d " %compteurD
print "compteurG = %d " %compteurG
print "\n{} Rotations!".format(RotationsD+1)
print "\n{} Rotations!".format(RotationsG+1)
print "Distance = %f " %distance_mesuree_m

stop()

GPIO.cleanup()